# 封装行为，而不仅仅是状态

在系统理论中，封装是处理大型和复杂系统结构时最有用的构造之一。在软件行业中，封装的价值是众所周知的。封装由编程语言构造支持，例如子例程和函数、模块和包、类等等。

模块和包解决了封装的更大规模需求，而类、子例程和函数解决了更细粒度的问题。多年来，我发现类似于类的封装构造似乎是开发人员最难掌握的。我们经常会发现一个类只有一个3000行的主方法，或者一个类只有用于其原始属性的set和get方法。这些示例表明参与开发的人没有完全理解面向对象的思维方式，未能充分利用对象作为建模构造的能力。对于熟悉POJO（Plain Old Java Object）和POCO（Plain Old C# Object或Plain Old CLR Object）这些术语的开发人员来说，回归到面向对象的基础是有意的——对象是简单明了的，但并不是愚蠢的。

一个对象封装了状态和行为，其中行为由实际状态定义。考虑一个门的对象。它有四种状态：关闭、打开、正在关闭、正在打开。它提供两个操作：打开和关闭。根据状态的不同，打开和关闭操作会有不同的行为。对象的这种固有属性使设计过程概念上简单化。它归结为两个简单的任务：将责任分配和委托给不同的对象，包括对象之间的交互协议。

实际上，最好通过一个示例来说明这个过程。假设我们有三个类：Customer（顾客）、Order（订单）和Item（商品）。Customer对象是存放信用额度和信用验证规则的自然容器。Order对象知道其关联的Customer，并且其addItem操作通过调用`customer.validateCredit(item.price())`来委托实际的信用检查。如果方法的后置条件失败，可以抛出异常并中止购买。

经验较少的面向对象开发人员可能会决定将所有业务规则封装到一个对象中，通常称为`OrderManager`或`OrderService`。在这些设计中，`Order`、`Customer`和`Item`被视为几乎只是记录类型。所有逻辑被提取出类，并在一个大的过程性方法中通过许多内部的*if-then-else*结构进行绑定。这些方法容易出错，几乎无法维护。原因是封装被破坏了。

因此，最终不要破坏封装，并利用编程语言的能力来维护封装。

由[Einar Landre](http://programmer.97things.oreilly.com/wiki/index.php/Einar_Landre)撰写
