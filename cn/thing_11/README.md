# 用领域语言编写代码

想象一下有两个代码库。在其中一个代码库中，你遇到了以下代码：

```
if (portfolioIdsByTraderId.get(trader.getId())
  .containsKey(portfolio.getId())) {...}
```

你摸了摸头，想知道这段代码可能是用来做什么的。它似乎是从一个`trader`对象中获取一个ID，然后使用该ID从一个“映射的映射”中获取一个Map集合，并检查另一个`portfolio`对象的ID是否存在于内部Map中。你又摸了摸头。你查找了一下`portfolioIdsByTraderId`的声明，发现了这个：

```
Map<int, Map<int, int>> portfolioIdsByTraderId;
```

渐渐地，你意识到这可能与判断`trader`是否有权限访问特定`portfolio`有关。当然，当某些代码关心`trader`是否有权限访问特定`portfolio`时，你可能会发现类似的查找代码片段——或者更有可能是类似但细微不同的代码片段。

在另一个代码库中，你遇到了以下代码：

```
if (trader.canView(portfolio)) {...}
```

没有摸头的困惑。你不需要知道交易员是如何判断的。也许在某个地方有一个类似“映射的映射”的数据结构。但这是`trader`的事情，与你无关。

那么，你更愿意在哪个代码库中工作呢？

从前，我们只有非常基本的数据结构：位和字节以及字符（实际上只是字节，但我们会假装它们是字母和标点符号）。十进制数在二进制中有些棘手，所以我们有几种大小的浮点类型。然后我们有了数组和字符串（实际上只是不同的数组）。然后我们有了栈、队列、哈希表、链表、跳表和许多其他*在现实世界中不存在的*令人兴奋的数据结构。 "计算机科学"是在花费大量精力将现实世界映射到我们受限制的数据结构中。真正的专家甚至可以记得他们是如何做到的。

然后我们得到了用户定义的类型！好吧，这不是什么新鲜事，但它确实改变了游戏规则。如果你的领域中包含像交易员和投资组合这样的概念，你可以使用名为Trader和Portfolio的类型对它们进行建模。但更重要的是，你可以使用领域术语来建模*它们之间的关系*。

如果你不使用领域术语进行编码，你就在隐含地（读：秘密地）理解“这里的”int表示交易员的标识方式，而“那里的”int表示投资组合的标识方式。（最好不要混淆它们！）如果你用一个算法片段来表示一个业务概念（"有些交易员不被允许查看某些投资组合——这是非法的"），比如一个键的存在关系映射中，你并没有为审计和合规人员做任何好事。

接下来的程序员可能不知道这个秘密，那么为什么不明确表达出来呢？使用一个键作为查找另一个执行存在性检查的键并不是非常明显。有人应该如何直观地理解这是实施防止利益冲突的业务规则的地方？

在代码中明确域概念意味着其他程序员可以比尝试将算法改造为他们对域的理解更容易地收集代码的“意图”。 这也意味着，当领域模型不断发展时（随着您对领域的理解不断加深，领域模型也会不断发展），您就处于改进代码的有利位置。 加上良好的封装，规则很可能只存在于一个地方，并且您可以更改它，而无需任何依赖代码变得更明智。

几个月后来处理这段代码的程序员会感谢你。几个月后来处理这段代码的程序员可能就是你自己。

由[Dan North](http://programmer.97things.oreilly.com/wiki/index.php/Dan_North)撰写
