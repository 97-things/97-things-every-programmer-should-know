# 进程间通信对应用响应时间的影响

响应时间对于软件的可用性至关重要。很少有什么事情比等待某个软件系统的响应更让人沮丧，特别是当我们与软件的交互涉及重复的刺激和响应周期时。我们感觉软件在浪费我们的时间，影响我们的工作效率。然而，导致响应时间不佳的原因并没有得到充分的认识，特别是在现代应用程序中。许多性能管理文献仍然关注数据结构和算法，这些问题在某些情况下确实可以产生影响，但在现代多层企业应用程序中很少会主导性能。

在这种应用程序中，当性能成为问题时，我的经验是检查数据结构和算法并不是改进的正确方向。响应时间最大程度上取决于作为刺激响应而进行的远程进程间通信（IPC）的数量。虽然可能存在其他本地瓶颈，但远程进程间通信的数量通常是主导因素。每个远程进程间通信都会对整体响应时间产生一定的延迟，而这些个别贡献会累积起来，特别是当它们按顺序发生时。

一个典型的例子是在使用对象-关系映射的应用程序中的"ripple loading"。Ripple loading描述了为构建对象图形所需的许多数据库调用的顺序执行（请参见Martin Fowler的《企业应用架构模式》中的"[Lazy Load](http://martinfowler.com/eaaCatalog/lazyLoad.html)"）。当数据库客户端是一个渲染网页的中间层应用服务器时，这些数据库调用通常在单个线程中顺序执行。它们的个别延迟累积，导致整体响应时间增加。即使每个数据库调用只需要10毫秒，一个需要1000个调用的页面（这并不少见）将至少显示10秒的响应时间。其他例子包括Web服务调用、Web浏览器的HTTP请求、分布式对象调用、请求-回复消息传递和使用自定义网络协议的数据网格交互。需要响应刺激的远程IPC越多，响应时间就会越长。

有一些相对明显和众所周知的策略可以减少每个刺激所需的远程进程间通信的数量。一种策略是应用简洁原则，优化进程之间的接口，以便以最少的交互量交换与手头任务相关的准确数据。另一种策略是在可能的情况下并行化进程间通信，这样整体响应时间主要由延迟最长的IPC驱动。第三种策略是缓存以前的IPC结果，以便未来的IPC可以通过命中本地缓存来避免。

在设计应用程序时，请注意每个刺激所需的进程间通信的数量。在分析性能不佳的应用程序时，我经常发现IPC与刺激的比例是千分之一。通过缓存、并行化或其他技术来减少这个比例，比更改数据结构选择或微调排序算法更有回报。

由[Randy Stafford](http://programmer.97things.oreilly.com/wiki/index.php/Randy_Stafford)撰写
