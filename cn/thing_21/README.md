# 将业务异常与技术异常区分开来

在运行时，事情出错通常有两个原因：技术问题导致我们无法使用应用程序，以及业务逻辑导致我们无法正确使用应用程序。大多数现代语言，如LISP、Java、Smalltalk和C#，都使用异常来表示这两种情况。然而，这两种情况是如此不同，它们应该被仔细区分开来。使用相同的异常层次结构，更不用说相同的异常类来表示它们，可能会造成混淆。

无法解决的技术问题可能是由于编程错误引起的。例如，如果你试图从一个大小为17的数组中访问第83个元素，那么程序显然是出错的，应该引发一些异常。更微妙的情况是使用不合适的参数调用某个库代码，导致库内部出现相同的情况。

试图解决自己造成的这些情况是错误的。相反，我们让异常上升到最高的架构层次，并让一些通用的异常处理机制尽力确保系统处于安全状态，比如回滚事务、记录和通知管理员，并向用户报告（礼貌地）。

这种情况的变体是当你处于“库的情况”时，调用者违反了你的方法的约定，例如传递一个完全奇怪的参数或没有正确设置一个依赖对象。这与从17个元素中访问第83个元素相当：调用者应该进行检查；不这样做是客户端的程序员错误。正确的响应是抛出一个技术异常。

另一种不同但仍然是技术问题的情况是程序由于执行环境的问题而无法继续，比如无响应的数据库。在这种情况下，你必须假设基础设施已经尽力解决了这个问题，比如修复连接并重试合理次数，但失败了。即使原因不同，对于调用代码来说，情况是类似的：它无能为力。因此，我们通过抛出异常来标识这种情况，并让它上升到通用的异常处理机制。

相比之下，我们还有一种情况，即由于领域逻辑原因无法完成调用。在这种情况下，我们遇到了一个异常情况，即异常、不寻常和不希望发生，但不是奇怪的或程序上的错误。例如，如果我尝试从一个余额不足的账户中提取资金。换句话说，这种情况是合同的一部分，抛出异常只是模型中的一条“替代返回路径”，客户端应该意识到并准备处理这种情况。对于这些情况，适当的做法是创建一个特定的异常或一个单独的异常层次结构，以便客户端可以根据自己的条件处理情况。

将技术异常和业务异常混在同一个层次结构中会模糊区别，并使调用者对方法的契约、调用前应确保的条件以及应该处理的情况产生困惑。将这些情况分开可以提供清晰度，并增加技术异常被某些应用程序框架处理的机会，而业务领域异常则由客户端代码考虑和处理。

由[Dan Bergh Johnsson](http://programmer.97things.oreilly.com/wiki/index.php/Dan_Bergh_Johnsson)撰写
