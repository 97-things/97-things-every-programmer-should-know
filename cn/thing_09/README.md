# 在责怪他人之前先检查自己的代码

开发人员——我们所有人！——经常很难相信自己的代码有问题。这么说来，代码出错的可能性实在是太小了，我们更愿意相信是编译器出了问题。

然而，事实上，代码由于编译器、解释器、操作系统、应用服务器、数据库、内存管理器或其他任何系统软件的错误而出错的情况非常（非常）罕见。是的，这些错误确实存在，但它们比我们想象的要少得多。

我曾经遇到过一个真正的问题，编译器的一个错误导致循环变量被优化掉了，但我更多的时候是想象我自己的编译器或操作系统有错误。在此过程中，我浪费了大量的时间、支持时间和管理时间，最后每次都发现问题其实是我的错误，感到有点愚蠢。

假设这些工具被广泛使用、成熟，并在各种技术堆栈中使用，就没有理由怀疑它们的质量。当然，如果这个工具是早期版本，或者全球只有少数人使用，或者是一个很少下载的0.1版本的开源软件，那么怀疑软件质量可能是有充分理由的。（同样，商业软件的alpha版本也可能有问题。）

考虑到编译器错误的罕见性，你最好把时间和精力投入到找出代码中的错误，而不是试图证明编译器的错误。所有常规的调试建议都适用，所以要隔离问题，取消调用，用测试代码包围它；检查调用约定、共享库和版本号；向他人解释问题；注意堆栈破坏和变量类型不匹配；在不同的机器上和不同的构建配置（如调试和发布版本）上尝试代码。

质疑自己和他人的假设。来自不同供应商的工具可能内置了不同的假设，同一供应商的不同工具也可能有不同的假设。
当其他人报告一个你无法重现的问题时，去看看他们在做什么。他们可能正在做一些你从未想过的事情，或者按照不同的顺序进行操作。

作为个人原则，如果我有一个无法确定原因的错误，并且开始认为是编译器的问题，那么就是时候查找堆栈破坏了。如果添加跟踪代码使问题移动位置，尤其如此。

多线程问题是导致人们头发白了、对计算机大喊大叫的另一个错误来源。在系统是多线程的情况下，所有建议采用简单代码的建议都会倍增。调试和单元测试不能可靠地找出此类错误，因此设计的简单性至关重要。

所以，在急于责怪编译器之前，请记住福尔摩斯的建议：“一旦你排除了不可能的，无论剩下的是多么不可思议，它必须是真相”，并将其优先于迪克·简特利的建议：“一旦你排除了不可能的，无论剩下的是多么不可能，它必须是真相。”

由[Allan Kelly](http://programmer.97things.oreilly.com/wiki/index.php/Allan_Kelly)撰写
